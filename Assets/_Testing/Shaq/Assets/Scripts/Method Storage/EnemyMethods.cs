using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.AI;
using UnityEngine.UI;
using UnityEngine.Events;

using Unity.Profiling;

public class EnemyMethods : MonoBehaviour
{
//    #region Variables

//    //---------------------------------------------------------------------------------------------------//
//    [Tooltip("The guard's target")]
//    [HideInInspector] public Vector3 target;

//    [Tooltip("The NavMesh Agent component the object that this script is attatched to")]
//    private NavMeshAgent agent;

//    [Tooltip("The path generated by the NavMesh Agent")]
//    private NavMeshPath path;

//    [Tooltip("The randomly generated point for guard to go to")]
//    private Vector3 searchLoc;

//    //---------------------------------------------------------------------------------------------------//
//    [Header("Object References")]

//    [Space(20)]

//    [Tooltip("References the player object")]
//    [SerializeField] private GameObject player;

//    [Tooltip("References the guard's eyeball prefab / object")]
//    [SerializeField] public EyeballScript eyeball;

//    [Tooltip("References the guard's animator script")]
//    [SerializeField] GuardAnimatorScript guardAnim;

//    [SerializeField] private GameObject surpriseVFX;

//    [SerializeField] private GameObject confusedVFX;

//    [Tooltip("Object reference to the security station / suspicion manager")]
//    [SerializeField] private GameObject securityStationObjRef;

//    [Tooltip("Script reference to the security station / suspicion manager")]
//    [SerializeField] private SuspicionManager securityStationScriptRef;

//    [Tooltip("List of Security Stations in the level")]
//    [SerializeField] private List<GameObject> securityStations;

//    //---------------------------------------------------------------------------------------------------//

//    [Header("Diagnostic Text")]

//    [Space(20)]

//    [Tooltip("References the state text (displays the state the guard is in)")]
//    [SerializeField] private Text stateText;

//    [Tooltip("References the target text (displays the guard's current target)")]
//    [SerializeField] private Text targetText;

//    //---------------------------------------------------------------------------------------------------//

//    [Header("Minimum Sus Levels for States")]

//    [Space(20)]

//    [Tooltip("Minimum Suspicion level to enter this state")]
//    //Implied Min Value of 0
//    [SerializeField] private float passiveSusMax = 3;

//    [Tooltip("Minimum Suspicion level to enter this state")]
//    [SerializeField] public float warySusMin = 3.1f;

//    [SerializeField] private float warySusMax = 4;

//    [Tooltip("Minimum Suspicion level to enter this state")]
//    [SerializeField] private float sussySusMin = 4.1f;

//    [SerializeField] private float sussySusMax = 5;

//    [Tooltip("Minimum Suspicion level to enter this state")]
//    //Implied Max Value of eyeball.susLevel max
//    [SerializeField] private float hostileSusMin = 5.1f;

//    //---------------------------------------------------------------------------------------------------//

//    [Header("Guard Movement Speeds")]

//    [Space(20)]

//    [Tooltip("The speed that the AI moves at in the PASSIVE state")]
//    [SerializeField] [Range(0, 5)] public float passiveSpeed = 1f;

//    [Tooltip("The speed that the AI moves at in the WARY state")]
//    [SerializeField] [Range(0, 5)] public float warySpeed = 1.5f;

//    [Tooltip("The speed that the AI moves at in the SUSPICIOS state")]
//    [SerializeField] [Range(0, 5)] public float susSpeed = 1f;

//    [Tooltip("The speed that the AI moves at in the STUNNED state")]
//    [SerializeField] [Range(0, 5)] public float stunSpeed = 0f;

//    [Tooltip("The speed that the AI moves at in the HOSTILE state")]
//    [SerializeField] [Range(0, 5)] public float hostileSpeed = 4f;

//    [Tooltip("The speed that the AI moves at in the ATTACK state")]
//    [SerializeField] [Range(0, 5)] public float attackSpeed = 0f;

//    //---------------------------------------------------------------------------------------------------//
//    [Header("Patrol Wait Time")]

//    [Space(20)]

//    [Tooltip("When enabled, the guard will wait when it reaches it's 'waypointNextDistance'")]
//    [SerializeField] private bool isPatrolWait;

//    [Tooltip("The amount of time that the guard waits when 'isWait' is enabled")]
//    [SerializeField] public float patrolWaitTime;

//    [Tooltip("The minimum generated value for the wait time")]
//    [SerializeField] [Range(1, 3)] private float patrolWaitMin = 1f;

//    [Tooltip("The maximum generated value for the wait time")]
//    [SerializeField] [Range(3, 5)] private float patrolWaitMax = 5f;


//    //---------------------------------------------------------------------------------------------------//
//    [Header("Suspicious Wait Time")]

//    [Space(20)]

//    [Tooltip("The minimum generated value for the wait time")]
//    [SerializeField] [Range(1, 3)] private float randWaitMin = 1f;

//    [Tooltip("The maximum generated value for the wait time")]
//    [SerializeField] [Range(3, 5)] private float randWaitMax = 5f;

//    [Tooltip("Randomly generated value inserted as the start of a timer (For guard SUS state waiting)")]
//    private float randWaitTime = 3f;

//    [Tooltip("The distance from the guard that a random point can be generated")]
//    [SerializeField] [Range(1, 3)] private float randPointRad = 1f;

//    //---------------------------------------------------------------------------------------------------//

//    [Header("Audio Variables")]

//    [Space(20)]

//    [SerializeField] private AudioSource audioSource;

//    [SerializeField] private bool isAudioSourcePlaying;

//    //---------------------------------------------------------------------------------------------------//

//    [Header("Debug / Testing Variables")]

//    [Space(20)]

//    public bool isStunned;

//    //Variable may need to be renamed in the future based on further implementations with Charlie
//    [Tooltip("Duration of the guard's Stun state duration")]
//    [SerializeField] private float stunTime;

//    [Tooltip("")]
//    private float stunTimeReset;

//    //Save implementation for next sprint
//    [SerializeField] [Range(0, 50)] private float guardKnockbackForce;

//    [Tooltip("Duration of the guard's Attack state duration")]
//    [SerializeField] private float attackTime;
//    private float attackTimeReset;

//    //---------------------------------------------------------------------------------------------------//

//    [Header("Misc. Variables")]

//    [Space(20)]

//    [Tooltip("The distance the guard needs to be from the target/player before it attacks them")]
//    [SerializeField] [Range(0, 2)] private float attackRadius = 10f;

//    [SerializeField] [Range(0, 10)] private float taserShotRadius;

//    [Tooltip("The distance the guards is from it's waypoint before it get's it's next waypoint")]
//    [SerializeField] private float waypointNextDistance = 2f;

//    [SerializeField] private GameObject playerCaptureTeleportLoc;

//    [SerializeField] private GameObject playerReleaseTeleportLoc;

//    private float oneTimeUseTimer = 2f;

//    private float oneTimeUseTimerReset;

//    //private bool surpriseVFXBoolCheck;

//    private float eyeballSightRangeRecord;

//    //Delete this in the future
//    //private System.Threading.Timer timer;

//    //---------------------------------------------------------------------------------------------------//

//    //Extremely temporary timer variables

//    [Header("Extremely temporary timer variables")]

//    [Space(20)]

//    [SerializeField] [Range(0, 10)] private float tempTaserTimer;

//    [Tooltip("References the taser prefab for the guard to spawn")]
//    [SerializeField] private GameObject taserProjectile;

//    [Tooltip("References the spawn location of the taser prefeab")]
//    [SerializeField] private GameObject taserSpawnLoc;

//    [Tooltip("Guard's stopping distance from the security station")]
//    [SerializeField] private float stoppingDistance = 2f;

//    private bool SussyWaypointMade;

//    private float fireRate = 5f;

//    [SerializeField] PlayerMovement playerMovenemtRef;

//    private bool ceaseFire;

//    [SerializeField] private GameObject beegPelvis;

//    #endregion

//    #region Enumerations

//    #region AI State Machine

//    public enum EnemyStates
//    {
//        PASSIVE,
//        WARY,
//        SUSPICIOUS,
//        HOSTILE,
//        RANGEDATTACK,
//        STUNNED
//    }

//    [Header("AI State")]

//    public EnemyStates stateMachine;

//    #endregion AI State Machine

//    #region AI Cycle Methods
//    [System.Serializable]
//    private enum CycleMethods
//    {
//        Cycle,
//        Reverse,
//        Random
//    }

//    [Header("Waypoint Cycling")]

//    [SerializeField] CycleMethods waypointMethod;

//    #endregion AI Cycle Methods

//    #endregion Enumerations

//    #region Waypoints Logic
//    [Header("Waypoints List")]
//    //WILL BREAK IF THE LIST IS NOT THE TRANSFORM DATA TYPE
//    [SerializeField] private List<Transform> waypoints;
//    //waypoints.Count will be used to get the number of points in the list (similar to array.Length)
//    private int waypointIndex = 0;


//    #endregion

//    #region Waypoints Functions
//    void SetNextWaypoint()
//    {
//        switch (waypointMethod)
//        {
//            case CycleMethods.Cycle:

//                if (waypointIndex >= waypoints.Count - 1)
//                {
//                    waypointIndex = 0;

//                    target = waypoints[0].position;
//                }
//                else
//                {
//                    waypointIndex++;

//                    target = waypoints[waypointIndex].position;
//                }
//                SetAIDestination(target);

//                break;

//            case CycleMethods.Reverse:

//                if (waypointIndex >= waypoints.Count - 1)
//                {
//                    waypointIndex = 0;

//                    waypoints.Reverse();

//                    target = waypoints[0].position;
//                }
//                else
//                {
//                    waypointIndex++;

//                    target = waypoints[waypointIndex].position;
//                }
//                SetAIDestination(target);

//                break;

//            case CycleMethods.Random:
//                //Probably going to get rid of this
//                print("Current cycling method is random");

//                break;

//            default:
//                print("Cycling method not found \a");
//                break;
//        }
//    }
//    #endregion Waypoints Functions

//    #region AI Methods

//    //---------------------------------//
//    // Called on Awake and initializes everything that is finalized and needs to be done at awake
//    public void Init()
//    {
//        //FIX THIS WHEN TELLING PEOPLE ITS FINE TO FUCK WITH GUARD
//        stateMachine = EnemyStates.PASSIVE;

//        isAudioSourcePlaying = false;

//        //Stores the user generated stun time
//        stunTimeReset = stunTime;

//        //Stores the user generated random direction time
//        agent = GetComponent<NavMeshAgent>();

//        agent.autoBraking = true;

//        SetAiSpeed(passiveSpeed);

//        //Checks to see if there is no value for the player object reference
//        if (player == null)
//        {
//            player = FindObjectOfType<PlayerMovement>().gameObject;
//        }

//        #region Waypoints Check / Initial Start
//        //checks to see if there are any objects in the waypoints list
//        if (waypoints.Count > 0)
//        {
//            target = waypoints[waypointIndex].position;
//        }
//        else
//        {
//            print("No waypoints added to guard instance");
//        }
//        #endregion Waypoints Check / Initial Start

//        FaceTarget(target);

//        stunTimeReset = stunTime;

//        path = new NavMeshPath();

//        if (guardAnim == null)
//        {
//            guardAnim = GetComponent<GuardAnimatorScript>();
//        }

//        oneTimeUseTimerReset = oneTimeUseTimer;

//        eyeballSightRangeRecord = eyeball.sightRange;

//        if (securityStationObjRef == null)
//        {
//            securityStationObjRef = GameObject.Find("Suspicion Manager");
//        }

//        if (playerMovenemtRef == null)
//        {
//            playerMovenemtRef = player.GetComponent<PlayerMovement>();
//        }

//        if (beegPelvis == null)
//        {
//            //Find a better way to do this
//            Debug.Log("WHERE'S THE FUCKING PLAYER PELVIS");
//        }

//        securityStations = new List<GameObject>(GameObject.FindGameObjectsWithTag("SecurityStation"));

//        ceaseFire = false;

//        NearestStation();
//    }//End Init


//    //---------------------------------//
//    // Updates the debug text above the guard's head
//    public void UpdateDebugText()
//    {
//        string methodStateText;

//        methodStateText = stateMachine.ToString();

//        stateText.text = methodStateText;


//        string methodTargetText;

//        methodTargetText = target.ToString();

//        targetText.text = methodTargetText;
//    }//End UpdateDebugText


//    //---------------------------------//
//    // Finds nearest security station
//    public GameObject NearestStation()
//    {
//        //Credit goes to Patrick for this code

//        float currentDistance;
//        float minDistance = Mathf.Infinity;

//        GameObject closestStation = null;

//        foreach (GameObject station in securityStations)
//        {
//            currentDistance = Vector3.Distance(station.transform.position, transform.position);

//            if (currentDistance < minDistance)
//            {
//                minDistance = currentDistance;

//                closestStation = station;
//            }
//        }
//        return closestStation;
//    }//End NearestStation


//    //---------------------------------//
//    // Constructs an empty game object with a transform component
//    //  - The constructed object is intended to be used as a waypoint for the guard
//    public GameObject GameObjectContructor(string objName, Vector3 objSpawnLoc)
//    {
//        GameObject go1 = new GameObject();
//        go1.name = objName;
//        go1.transform.position = objSpawnLoc;

//        return go1;
//    }//End GameObjectConstructor


//    //---------------------------------//
//    // Alert's the guard
//    public void Alert(Vector3 alertLoc)
//    {
//        eyeball.susLevel = 10;

//        stateMachine = EnemyStates.HOSTILE;

//        if (eyeball.canCurrentlySeePlayer == false)
//        {
//            //target = alertLoc;
//            eyeball.lastKnownLocation = alertLoc;
//        }
//        else
//        {
//            target = eyeball.lastKnownLocation;
//        }
//    }//End Alert


//    //---------------------------------//
//    // Method for facing the player when the AI is withing stopping distance of the player
//    public void FaceTarget(Vector3 target)
//    {
//        Vector3 direction = (target - transform.position).normalized;

//        Quaternion lookRotation = Quaternion.identity;
//        if (direction.x != 0 && direction.z != 0)
//        {
//            lookRotation = Quaternion.LookRotation(new Vector3(direction.x, 0, direction.z));
//        }

//        //The float at the end is arbitrarily high so that the guard properly faces the player / target when stationary or making a tight corner
//        transform.rotation = Quaternion.Slerp(transform.rotation, lookRotation, Time.deltaTime * 60000000f);
//    }//End FaceTarget


//    //---------------------------------//
//    // Changes the guard's speed and destination in one go, just me being lazy to be honest [Come back and change this to be more professional before Kevin & Patrick comb through the code]
//    public void SetSpeedAndDest(float speed, Vector3 point)
//    {
//        SetAiSpeed(speed);

//        SetAIDestination(point);
//    }//End SetSpeedAndDest


//    //---------------------------------//
//    // Sets the AI speed
//    // Needs to be reworked / improved
//    public void SetAiSpeed(float speed)
//    {
//        agent.speed = Mathf.Lerp(agent.speed, speed, 1);//End SetSpeed

//        guardAnim.SetAgentSpeed(speed);
//    }//End SetAiSpeed


//    //---------------------------------//
//    // Function for setting AI destination
//    public void SetAIDestination(Vector3 point) => agent.SetDestination(point);//End SetAIDestination


//    //---------------------------------//
//    // Finding and eating donuts
//    void OnTriggerEnter(Collider other)
//    {
//        if (other.gameObject.GetComponent<BaitItemScript>() != null)
//        {
//            Destroy(other.gameObject);
//        }
//    }//End OnTriggerEnter

//    //---------------------------------//
//    // Generates a random point for the guard to go to
//    private Vector3 GenerateRandomPoint()
//    {
//        //Generates the initial random point
//        Vector3 randpoint = Random.insideUnitSphere * randPointRad;

//        //Returns a bool
//        //First portion tests the randomly generated point to see if it can be reached.
//        //Second portion tests the path to the genreated point and to see if it's possible to reach that point
//        if (NavMesh.SamplePosition(randpoint + transform.position, out NavMeshHit hit, randPointRad, 1) && NavMesh.CalculatePath(transform.position, hit.position, NavMesh.AllAreas, path))
//        {
//            searchLoc = hit.position;
//            return searchLoc;
//        }
//        else
//        {
//            print("Point or Path is invalid");
//            return transform.position;
//        }
//    }//End GenerateRandomPoint


//    //---------------------------------//
//    // Draws shapes only visible in the editor
//    private void OnDrawGizmos()
//    {
//        Gizmos.color = Color.red;
//        Gizmos.DrawWireSphere(transform.position, attackRadius);

//        Gizmos.color = Color.blue;
//        Gizmos.DrawWireSphere(transform.position, randPointRad);

//        Gizmos.color = Color.yellow;
//        Gizmos.DrawWireSphere(transform.position, taserShotRadius);

//        Gizmos.color = Color.blue;
//        Gizmos.DrawSphere(searchLoc, .5f);

//#if UNITY_EDITOR
//        Gizmos.color = Color.white;
//        Gizmos.DrawSphere(target, 0.75f);
//#endif

//    }//End OnDrawGizmos


//    public IEnumerator IBreakFreeDelay()
//    {
//        yield return new WaitForSeconds(2);
//    }

//    #endregion AI Methods
}
